Creating drivers and writing code for the IOP
==============================================

IOPs contain a soft `Xilinx MicroBlaze processor <https://en.wikipedia.org/wiki/MicroBlaze>`_, peripherals `AXI Timer <http://www.xilinx.com/support/documentation/ip_documentation/axi_timer/v2_0/pg079-axi-timer.pdf>`_, `AXI IIC <http://www.xilinx.com/support/documentation/ip_documentation/axi_iic/v2_0/pg090-axi-iic.pdf>`_, `AXI SPI <http://www.xilinx.com/support/documentation/ip_documentation/axi_quad_spi/v3_2/pg153-axi-quad-spi.pdf>`_, `AXI GPIO <http://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf>`_ a configurable switch and an interface port to a Pmod. An IOP can be used as a flexible controller for different types of peripherals.

For external peripherals, the intention is that any low-level control, or real-time requirements can be met by the IOP, rather than the main ARM A9. The ARM A9 is an Aplication processor, not a real time processor. 

The IOP switch can be configured to route signals between the Pmod interface, and the available peripherals. In this way, an IIC, SPI, or custom peripheral can be supported on the same physical port using a single overlay. i.e. there is no need to create a new FPGA to support a different peripherals. 

IOPs can also be used standalone to offload some processing from the main processer. The IOPs are running at 100MHz compared to the Dual Core ARM A9 running at 650MHz, which should be taken into account when offloading application code.

Compiling code for the IOP
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Code for the MicroBlaze processor inside the IOP can be written in C or C++. 

The Xilinx SDK (Software Development Kit) can be installed on a host computer and used to create a software project to build applications for the MicroBlaze inside the IOP. This is the standard way of developing software for a MicroBlaze.

If Vivado is required, you should use Vivado 2015.4. If SDK is required, you should use SDK 2015.4.

`Download Xilinx Vivado and SDK 2015.4 <http://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2015-4.html>`_

You can use the Vivado HLx Web Install Client and select SDK and/or Vivado during the installation.

Create SDK Project
------------------

To create a project in SDK for the IOP, the .hdf hardware definition file for the *OVERLAY*, which includes an instance of the IOP is required. This step requires that you have Vivado and SDK installed on the host machine.

The .hdf can be generated by running the tcl to build the Vivado project for one of the overlays here:

Pynq/zybo/vivado/

You need to open the project, and Export the Design to generate the .hdf. (You do not need to build the bitstream.)

In SDK, create a *New Hardware Platfrom Specification* project, and link it to the .hdf file. Then, import the BSP from `the Pynq GitHub repository <https://github.com/Xilinx/Pynq/tree/master/zybo/sdk>`_. 

A new Application can then be created.

Build existing projects with makefile
-------------------------------------

The SDK projects in the GitHub contain makefiles to build the projects. This step requires that you have SDK installed on the host machine.

The IOP code can be compiled by running make from:

    Pynq\\zybo\\sdk\\

This will built all the projects set in MBBINS at the top of the makefile

Individual projects can be build by navigating to the *<project directory>\\Debug* and running make

Copy existing project
---------------------

Rather than create your own project, you can use an existing project as a starting point for your code. This step requires that you have SDK installed on the host machine.

To do this, copy the project directory and rename it to your application name. 

Modify or replace the .c file in the src/ with your C code. The .bin file generated will have the same base name as your C file. 
e.g. if you c code is my_peripheral.c, the generated .elf and .bin will be my_peripheral.elf or my_peripheral.bin.

We encourage the following convention for naming drivers <pmod|grove>_<peripheral>

You will need to updates references from the old project name to your new project name in <project directory>\\Debug\\makefile and <project directory>\\Debug\\src\\subdir.mk

If you want your project to build as part of the main Pynq build (i.e. your project will get built with the same makefile as all the other peripherals), you should also append the bin name of your project to the MBBINS variable at the top of the makefile in:

    Pynq\\zybo\\sdk

Compile on the board
--------------------

You can also write C code, and compile it directly on the Zybo board. The compiler for MicroBlaze is available in xtools in the home area. 

Binary file
-----------

Compiling code results in an .elf executable file. A .bin file (binary file) is required to download to the IOP memory. 

A .bin file can be generated from an elf by running:

    mb-objcopy -O binary input_file.elf outputfile.bin

This is included in the makefiles builds for existing peripheral projects. 

IOP Memory
^^^^^^^^^^

The IOP instruction and data memory is implemented in a dual port Block RAM, with one port connected to the IOP, and the other to the ARM A9. This allows an executable to be written from the ARM A9 (i.e. the Pynq environment) to the IOP instruction memory. The IOP can also be reset from Pynq, allowing the IOP to start executing the new program. The IOP data memory, is also used to communicate between the Pynq environment and the IOP.

Memory map
----------

The IOP memory is 32K (0x8000). Instruction memory for the IOP starts at address 0x0.
Pynq and the application running on the IOP can write to anywhere in the shared memory space.  

When building the software project, the compiler will only ensure that the application and allocated stack and heap fit into the BRAM, but for communication between the ARM A9 and IOP, and additional data area must be available.
There is no memory management in the IOP. You must ensure the application, including stack and heap, do not overflow into the defined data area. Remember that declaring a stack and heap size, only allocates space to the stack and heap. No boundary is created, so if sufficient space was not allocated, the stack and heap may overflow.

It is recommended to follow the convention for data communication between the two processors. These MAILBOX values are defined in the pmod.h file.  


* Instruction memory offset  = 0x0
* Instruction memory size    = 0x6fff

* MAILBOX_OFFSET             = 0x7000
* MAILBOX_SIZE               = 0x1000

Relative to Data area:
* MAILBOX_PY2IOP_CMD_OFFSET  = 0xffc
* MAILBOX_PY2IOP_ADDR_OFFSET = 0xff8
* MAILBOX_PY2IOP_DATA_OFFSET = 0xf00

i.e. A command will be written from the Pynq environment to the address 0x0x8ffc

The IOP must read this location, decode the command and carry out the required operation.

If returning a single value (e.g. from pythong, .read() ) it should be written to location 0xf00
The Pynq application should then read the value back from here. 

There is also a larger data area, which could be used for example, to log data. 

IOP Switch
^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are 8 data pins on a Pmod port, that can be connected to any of 16 internal peripheral signals (GPIO, SPI, IIC, Timer). 

Switch mappings used for IOP Switch configuration:

* #define GPIO_0 0x0
* #define GPIO_1 0x1
* #define GPIO_2 0x2
* #define GPIO_3 0x3
* #define GPIO_4 0x4
* #define GPIO_5 0x5
* #define GPIO_6 0x6
* #define GPIO_7 0x7
* #define SCL    0x8
* #define SDA    0x9
* #define SPICLK 0xa
* #define MISO   0xb
* #define MOSI   0xc
* #define SS     0xd
* #define BLANK  0xe

If two or more pins are connected to the same signal, the pins are OR'd together. 

Each pin can be configured by writing a 4 bit value to the corresponding place in the IOP Switch configuration register. 

The IOP Switch can be (re)configured by writing a 32 bit value (8x 4 bits) to the IOP Switch configuration register. The configuration register is at location 0x0 of the IOP Switch address.

The IOP Address is:

    IOPMM_SWITCHCONFIG_BASEADDR    = 0x44A00000

Pin 0 is controlled by the most significant 4 bits, and Pin 7 is the least significant 4 bits. 

For example, to connect the physical pins GPIO 0-7 to the internal GPIO_0 - GPIO_7, the value 0x01234567 should be written to the IOP Switch configuration register.

Before configuring the switch, it should first be isolated. To do this, write '0' to the MSB of the SWITCH_BASEADDR+0x4 register. To reconnect it, write '1' to the MSB.

e.g.

    Xil_Out32(SWITCH_BASEADDR+0x4,0x00000000); // isolate switch by writing 0 to bit 31

    Xil_Out32(SWITCH_BASEADDR, switchConfigValue); // Set pin configuration

    Xil_Out32(SWITCH_BASEADDR+0x4,0x80000000); // Re-enable Swtch by writing 1 to bit 31
   

For the IOP, the following function, part of the provided SDK BSP (pmod.h/.c) can be used to configure the switch. 

void configureSwitch(char pin1, char pin2, char pin3, char pin4, char pin5, char pin6, char pin7, char pin8);

From Python all the constants and addresses for the IOP can be found in:

    Pynq\\python\\pmods\\pmod_const.py

For the IOP, all constants and addresses can be found in the pmod.h and pmod.c code included int he BSP:

Pynq\\zybo\\sdk\\standalone_bsp_mb1\\mb_1_microblaze_1\\libsrc\pmodiop_v0_1\\src

Pmod board support package
^^^^^^^^^^^^^^^^^^^^^^^^^^^

pmod.h
^^^^^^^^^^^^^^^^^^^^^
pmod.h contains an API and definitions that can be used to write code for an IOP.

   Pynq\\zybo\\sdk\\standalone_bsp_mb1\\mb_1_microblaze_1\\libsrc\pmodiop_v0_1\\src

Selecting which IOP to run the application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The shared memory is the only cocnnection between the ARM A9 and the IOPs. 

The shared memory is mapped to the ARM A9 address space at the following locations:

IOP 1 BRAM : 0x40000000

IOP 2 BRAM : 0x42000000

IOP 3 BRAM : 0x44000000

IOP 4 BRAM : 0x46000000

However, for each IOP, the MicroBlaze sees only its own address space. i.e. BRAM, Timer, IOP Switch, IIC, and SPI have the same addresses in each IOP's address space. 

This means, C code written for one IOP can run on any of the other IOPs simply by writing the application (.bin file) to the appropriate IOP's BRAM from the ARM A9. 


Example
^^^^^^^^^^^^^^^^^^^^^^^^^^^


Taking PMOD ALS as an example, first open the pmod_als.c file:

    Pynq/zybo/sdk/pmodals/src/pmod_als.c

Note that the pmod.h header file is included.

Some COMMANDS are defined by the user. These values can be chosen to be any value, but must correspond with the Python part of the driver. 

By convention, 0x0 is reserved for no command/idle/acknowledge, and operations for the IOP can start at command 0x1.

The ALS peripheral has as SPI interface. Note the user defined function get_sample() which calls an SPI function spi_transfer().  

The SPI API is included in pmod.h.

In main() notice configureSwitch() is called to initialize the switch with a static configuration. This means that if you want to use this code with a different pin configuration, the c code must be changed and recompiled. 

Next, the while(1) loop is entered. In this loop the IOP continually checks the MAILBOX_CMD_ADDR for a non-zero command. Once a command is received from Python, the command is decoded, and executed. 

Taking the first case, reading a value:

    case READ_SINGLE_VALUE:

        MAILBOX_DATA(0) = get_sample();

        MAILBOX_CMD_ADDR = 0x0;

get_sample() is called and a value returned to the first position (0) of the MAILBOX_DATA.

MAILBOX_CMD_ADDR is reset to 0x0 to acknowledge to the Pynq enviroment that the operation is complete and data is available in the mailbox. 

Examine Python Code
-------------------

Next examine the Python code.
 
   Pynq//tree//master//python//pynq//pmods//pmod_als.py
   
First the _iop, pmod_const and MMIO are imported. These are all constituents of an IOP.

from . import _iop
from . import pmod_const
from pynq import MMIO

The IOP module is imported, along with the Pmod constant definitions (pin mappings) and the MMIO (interface to shared memory).

The .bin for the IOP is declared. This is the application executable, and will be loaded into the IOP instruction memory. 

ALS_PROGRAM = "als.bin"

The ALS class is defined:

class ALS(object):

The initialization function for the module requires a pmod id/IOP number. For Grove peripherals and the StickIt connector, the StickIt port number could also be used for initialization.

    def __init__(self, pmod_id):

This will be used to load the application code into the appropriate IOP. The __init__ is called when a module is instantiated. e.g. from Python:

    als = ALS(1)

_iop.request_iop() instantiates an instance of the _iop on the specified pmod_id and loads the .bin file (ALS_PROGRAM) into the instruction memory of the appropriate IOP

    self.iop = _iop.request_iop(pmod_id, ALS_PROGRAM)

MMIO is used to read and write from the shared memory

    self.mmio = self.iop.mmio

log_interval_ms is a variable specific to this application.

    self.log_interval_ms = 1000

iop.start() resets the IOP. After this, the IOP will start running the new application.    

    self.iop.start()

Reading a Value
---------------

The read() function 

    def read(self)

mmio.write() writes a value representing a command to the COMMAND area in the shared memory, in this case "3". This value is user defined in the Python code, and must match the value the C program running on the IOP expects for the same funciton.

        self.mmio.write(pmod_const.MAILBOX_OFFSET+\
                        pmod_const.MAILBOX_PY2IOP_CMD_OFFSET, 3)     

When the IOP is finished, it will write 0x0 to the command area. The code now uses mmio.read() to check if the command is still 3, and if it is, it loops.  

        while (self.mmio.read(pmod_const.MAILBOX_OFFSET+\
                                pmod_const.MAILBOX_PY2IOP_CMD_OFFSET) == 3)
            pass
            
Once the command is no longer 3, i.e. the acknowledge has been received, the result is read from the DATA area of the shared memory MAILBOX_OFFSET. Using mmio.read()

        return self.mmio.read(pmod_const.MAILBOX_OFFSET)

Notice the pmod_const values are used in these function calls. 