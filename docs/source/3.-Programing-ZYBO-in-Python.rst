*****************************
Zynq A9 programming in Python
*****************************


.. contents:: Table of Contents
   :depth: 2

We show here an example of how to run Python on Zybo with Pynq.  All Python is running exclusively on the ARM Cortex-A9 processor.  This example, which is based on calculating the factors and primes of integer numbers, give us a sense of the performance available when running on a 650MHz ARM Cortex-A9 dual core processor running Ubuntu.  


The factors_and_primes module
=============================

The `factors_and_primes` module can be found in the pyxi.examples package.  It contains some sample functions to calculate the factors and primes of integers.  We will use three functions from the `factors_and_primes` module to demonstrate programming the ARM A9 CPU with MicroPython.  

factorize(n)::
Calculate all factors of integer n
primes_between(interval_min, interval_max)::
Find all primes in the interval defined by interval_min, interval_max
print_ints_with_most_factors(interval_min, interval_max)::
Reports integers with most factors in a given integer range


Let's start by importing the `factors_and_primes` module as `fp`.

.. code-block:: python

    >>> from examples import factors_and_primes as fp

Next we will call the `factorize()` function to calculate the factors of an integer.


**factorize()**

.. code-block:: python

    >>> fp.factorize(1066)
    [1, 2, 13, 26, 41, 82, 533, 1066]

The `primes_between()` function can tell us how many prime numbers there are in an integer range.  Let's try it for the interval 1 through 1066.

**primes_between()**

.. code-block:: python

  >>> fp.primes_between(1, 1066)
  [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063]


The answer is quite a few!  We can use one of Python's built-in methods `len()` to count them all.


Using built-in functions
------------------------

We can use one of Python's built-in methods `len()` to count them the primes.

**len()**

.. code-block:: python

  >>> len(fp.primes_between(1, 1066))
  180

And we can combine `len()` with another built-in method, `sum()`, to calculate the average of the 180 prime numbers.

**sum()**

.. code-block:: python

  >>> primes_1066 = fp.primes_between(1, 1066)
  >>> sum(primes_1066) / len(primes_1066)
  486.2056

This result makes sense intuitively because prime numbers are known to become less frequent for larger number intervals.  These examples demonstrate how Python treats functions as first-class objects so that functions may be passed as parameters to other functions.  This is a key property of functional programming and demonstrates the power of Python (and MicroPython).

We can use list comprehensions (a 'Pythonic' form of the map-filter-reduce template) to 'mine' the factors of 1066 to find those factors that end in the digit '3'.

**str(), endswith()**

.. code-block:: python

  >>> [x for x in fp.primes_between(1, 1066) if str(x).endswith('3')]
  [3, 13, 23, 43, 53, 73, 83, 103, 113, 163, 173, 193, 223, 233, 263, 283, 293, 313, 353, 373, 383, 433, 443, 463, 503, 523, 563, 593, 613, 643, 653, 673, 683, 733, 743, 773, 823, 853, 863, 883, 953, 983, 1013, 1033, 1063]


This code tells MicroPython to first convert each prime between 1 and 1066 to a string and then to return those nu  mbers whose string representation end with the number '3'.  It uses the built-in `str()` and `endswith()` me  thods to test each prime for inclusion in the list.  A list of Python's b

And because we really want to know what fraction of the 180 primes of 1066 end in a '3', we can calculate  ...

**len(), str(), endswith()**

.. code-block:: python

  >>> primes_1066 = fp.primes_between(1, 1066)
  >>> len([x for x in primes_1066 if str(x).endswith('3')]) / len(primes_1066)
  0.25

These examples demonstrate how Python is a modern, *multi-paradigmatic* language.  More simply, it continually integrates the best features of other leading languages, including functional programming constructs.  Consider how many lines of code you would need to implement the list comprehension above in C and you get an appreciation of the power of   *productivity-layer* languages.  Higher levels of programming abstraction really do result in higher programm  er productivity!


More intensive calculations
---------------------------

To stress the A9 a little more, we will run a script to determine the integer number, or numbers, that have the most factors between 1 and 1066, using the `print_ints_with_most_factors()` function from the `factors_and_primes` module. 

**print_ints_with_most_factors()**

.. code-block:: python

  >>> fp.print_ints_with_most_factors(1, 1066  )

  Between 1 and 1066 the number/s with the most factors:

  840 ... with the following 32 factors:
  [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 20, 21, 24, 28, 30, 35, 40, 42, 56, 60, 70, 84, 105, 120, 140, 168, 210, 280, 420, 840]
  The prime number factors of 840 are: [1, 2, 3, 5, 7]


The A9 remains quite responsive.  Running this for much larger numbers, say 50,000, will demonstrate noticeably slower responses as we would expect.

The source code for the functions above is available in the file `examples/factors_and_primes.py`  Reviewing the code wil l give you a better appreciation for the power of MicroPython both in terms of Python language covera  ge and performance.